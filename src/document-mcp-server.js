/**
 * WorkflowMCP Document Management Server - Phase 2.7
 * SQLite Í∏∞Î∞ò Î¨∏ÏÑú Í¥ÄÎ¶¨ Ï†ÑÏö© MCP ÏÑúÎ≤Ñ
 * ÌîÑÎ°úÏ†ùÌä∏ Î¨∏ÏÑúÎ•º Ï≤¥Í≥ÑÏ†ÅÏúºÎ°ú Ï†ÄÏû•, Í≤ÄÏÉâ, Í¥ÄÎ¶¨
 */

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { 
  CallToolRequestSchema, 
  ListToolsRequestSchema
} from '@modelcontextprotocol/sdk/types.js';
import sqlite3 from 'sqlite3';
import { open } from 'sqlite';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Database path
const DB_PATH = path.resolve(__dirname, '../data/workflow.db');

let db;

/**
 * ÏÑúÎ≤Ñ Ï¥àÍ∏∞Ìôî
 */
async function initializeServer() {
  console.log('üìö Initializing Document Management MCP Server...');
  
  try {
    db = await open({
      filename: DB_PATH,
      driver: sqlite3.Database
    });
    await db.exec('PRAGMA foreign_keys = ON');
    
    // Check if document tables exist
    const tables = await db.all(`
      SELECT name FROM sqlite_master 
      WHERE type='table' AND name LIKE '%document%'
    `);
    
    if (tables.length === 0) {
      console.log('‚ö†Ô∏è  Document tables not found. Please run migration first:');
      console.log('   node src/database/migrate-documents.js');
      process.exit(1);
    }
    
    console.log('‚úÖ Document Management database ready');
    return true;
  } catch (error) {
    console.error('‚ùå Database initialization failed:', error);
    throw error;
  }
}

// MCP ÏÑúÎ≤Ñ ÏÉùÏÑ±
const server = new Server({
  name: 'workflow-document-mcp',
  version: '2.7.0'
});

// =============================================
// MCP ÎèÑÍµ¨ Î™©Î°ù Ï†ïÏùò
// =============================================

server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      // Î¨∏ÏÑú ÏÉùÏÑ± Î∞è Í¥ÄÎ¶¨
      {
        name: 'create_document',
        description: 'ÏÉà Î¨∏ÏÑúÎ•º ÏÉùÏÑ±ÌïòÍ≥† SQLiteÏóê Ï†ÄÏû•',
        inputSchema: {
          type: 'object',
          properties: {
            title: { type: 'string', description: 'Î¨∏ÏÑú Ï†úÎ™©' },
            content: { type: 'string', description: 'Î¨∏ÏÑú ÎÇ¥Ïö© (Markdown ÌòïÏãù)' },
            doc_type: { 
              type: 'string', 
              enum: ['test_guide', 'test_results', 'analysis', 'report', 'checklist', 'specification', 'meeting_notes', 'decision_log'],
              description: 'Î¨∏ÏÑú Ïú†Ìòï' 
            },
            category: { type: 'string', description: 'Ïπ¥ÌÖåÍ≥†Î¶¨ (Ïòà: phase_2.6, testing)' },
            tags: { 
              type: 'array', 
              items: { type: 'string' }, 
              description: 'ÌÉúÍ∑∏ Î™©Î°ù' 
            },
            summary: { type: 'string', description: 'Î¨∏ÏÑú ÏöîÏïΩ' },
            linked_entity_type: { 
              type: 'string', 
              enum: ['prd', 'task', 'plan'], 
              description: 'Ïó∞Í≤∞Ìï† ÏóîÌÑ∞Ìã∞ Ïú†Ìòï (ÏÑ†ÌÉùÏÇ¨Ìï≠)' 
            },
            linked_entity_id: { type: 'string', description: 'Ïó∞Í≤∞Ìï† ÏóîÌÑ∞Ìã∞ ID (ÏÑ†ÌÉùÏÇ¨Ìï≠)' },
            link_type: { 
              type: 'string', 
              enum: ['specification', 'test_plan', 'result', 'analysis', 'notes'],
              description: 'ÎßÅÌÅ¨ Ïú†Ìòï (ÏÑ†ÌÉùÏÇ¨Ìï≠)' 
            }
          },
          required: ['title', 'content', 'doc_type']
        }
      },
      
      {
        name: 'search_documents',
        description: 'Full-text searchÎ°ú Î¨∏ÏÑú Í≤ÄÏÉâ',
        inputSchema: {
          type: 'object',
          properties: {
            query: { type: 'string', description: 'Í≤ÄÏÉâ ÏøºÎ¶¨' },
            doc_type: { 
              type: 'string', 
              enum: ['test_guide', 'test_results', 'analysis', 'report', 'checklist', 'specification', 'meeting_notes', 'decision_log'],
              description: 'ÌäπÏ†ï Î¨∏ÏÑú Ïú†ÌòïÏúºÎ°ú ÌïÑÌÑ∞ (ÏÑ†ÌÉùÏÇ¨Ìï≠)' 
            },
            category: { type: 'string', description: 'ÌäπÏ†ï Ïπ¥ÌÖåÍ≥†Î¶¨Î°ú ÌïÑÌÑ∞ (ÏÑ†ÌÉùÏÇ¨Ìï≠)' },
            limit: { type: 'integer', default: 10, description: 'Í≤∞Í≥º Ï†úÌïú Ïàò' }
          },
          required: ['query']
        }
      },
      
      {
        name: 'get_document',
        description: 'IDÎ°ú ÌäπÏ†ï Î¨∏ÏÑú Ï°∞Ìöå',
        inputSchema: {
          type: 'object',
          properties: {
            id: { type: 'integer', description: 'Î¨∏ÏÑú ID' }
          },
          required: ['id']
        }
      },
      
      {
        name: 'update_document',
        description: 'Í∏∞Ï°¥ Î¨∏ÏÑú ÏóÖÎç∞Ïù¥Ìä∏',
        inputSchema: {
          type: 'object',
          properties: {
            id: { type: 'integer', description: 'Î¨∏ÏÑú ID' },
            title: { type: 'string', description: 'Î¨∏ÏÑú Ï†úÎ™©' },
            content: { type: 'string', description: 'Î¨∏ÏÑú ÎÇ¥Ïö©' },
            summary: { type: 'string', description: 'Î¨∏ÏÑú ÏöîÏïΩ' },
            status: { 
              type: 'string', 
              enum: ['draft', 'review', 'approved', 'archived'],
              description: 'Î¨∏ÏÑú ÏÉÅÌÉú' 
            },
            tags: { 
              type: 'array', 
              items: { type: 'string' }, 
              description: 'ÌÉúÍ∑∏ Î™©Î°ù' 
            }
          },
          required: ['id']
        }
      },
      
      {
        name: 'delete_document',
        description: 'Î¨∏ÏÑú ÏÇ≠Ï†ú',
        inputSchema: {
          type: 'object',
          properties: {
            id: { type: 'integer', description: 'Î¨∏ÏÑú ID' }
          },
          required: ['id']
        }
      },
      
      {
        name: 'list_documents',
        description: 'Î¨∏ÏÑú Î™©Î°ù Ï°∞Ìöå',
        inputSchema: {
          type: 'object',
          properties: {
            doc_type: { 
              type: 'string', 
              enum: ['test_guide', 'test_results', 'analysis', 'report', 'checklist', 'specification', 'meeting_notes', 'decision_log'],
              description: 'ÌäπÏ†ï Î¨∏ÏÑú Ïú†ÌòïÏúºÎ°ú ÌïÑÌÑ∞' 
            },
            category: { type: 'string', description: 'ÌäπÏ†ï Ïπ¥ÌÖåÍ≥†Î¶¨Î°ú ÌïÑÌÑ∞' },
            status: { 
              type: 'string', 
              enum: ['draft', 'review', 'approved', 'archived'],
              description: 'ÌäπÏ†ï ÏÉÅÌÉúÎ°ú ÌïÑÌÑ∞' 
            },
            limit: { type: 'integer', default: 20, description: 'Í≤∞Í≥º Ï†úÌïú Ïàò' }
          }
        }
      },
      
      {
        name: 'import_markdown_file',
        description: 'Í∏∞Ï°¥ Markdown ÌååÏùºÏùÑ Î¨∏ÏÑúÎ°ú Í∞ÄÏ†∏Ïò§Í∏∞',
        inputSchema: {
          type: 'object',
          properties: {
            file_path: { type: 'string', description: 'Í∞ÄÏ†∏Ïò¨ Markdown ÌååÏùº Í≤ΩÎ°ú' },
            doc_type: { 
              type: 'string', 
              enum: ['test_guide', 'test_results', 'analysis', 'report', 'checklist', 'specification', 'meeting_notes', 'decision_log'],
              description: 'Î¨∏ÏÑú Ïú†Ìòï' 
            },
            category: { type: 'string', description: 'Ïπ¥ÌÖåÍ≥†Î¶¨' },
            tags: { 
              type: 'array', 
              items: { type: 'string' }, 
              description: 'ÌÉúÍ∑∏ Î™©Î°ù' 
            },
            auto_summary: { type: 'boolean', default: true, description: 'ÏûêÎèô ÏöîÏïΩ ÏÉùÏÑ± Ïó¨Î∂Ä' }
          },
          required: ['file_path', 'doc_type']
        }
      },
      
      {
        name: 'link_document',
        description: 'Î¨∏ÏÑúÎ•º PRD, Task, PlanÏóê Ïó∞Í≤∞',
        inputSchema: {
          type: 'object',
          properties: {
            document_id: { type: 'integer', description: 'Î¨∏ÏÑú ID' },
            entity_type: { 
              type: 'string', 
              enum: ['prd', 'task', 'plan'],
              description: 'Ïó∞Í≤∞Ìï† ÏóîÌÑ∞Ìã∞ Ïú†Ìòï' 
            },
            entity_id: { type: 'string', description: 'Ïó∞Í≤∞Ìï† ÏóîÌÑ∞Ìã∞ ID' },
            link_type: { 
              type: 'string', 
              enum: ['specification', 'test_plan', 'result', 'analysis', 'notes'],
              default: 'notes',
              description: 'ÎßÅÌÅ¨ Ïú†Ìòï' 
            }
          },
          required: ['document_id', 'entity_type', 'entity_id']
        }
      },
      
      {
        name: 'get_document_links',
        description: 'Î¨∏ÏÑúÏùò Î™®Îì† Ïó∞Í≤∞ Í¥ÄÍ≥Ñ Ï°∞Ìöå',
        inputSchema: {
          type: 'object',
          properties: {
            document_id: { type: 'integer', description: 'Î¨∏ÏÑú ID' }
          },
          required: ['document_id']
        }
      }
    ]
  };
});

// =============================================
// ÎèÑÍµ¨ Ìï∏Îì§Îü¨ Íµ¨ÌòÑ
// =============================================

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  try {
    switch (name) {
      case 'create_document':
        return await handleCreateDocument(args);
      case 'search_documents':
        return await handleSearchDocuments(args);
      case 'get_document':
        return await handleGetDocument(args);
      case 'update_document':
        return await handleUpdateDocument(args);
      case 'delete_document':
        return await handleDeleteDocument(args);
      case 'list_documents':
        return await handleListDocuments(args);
      case 'import_markdown_file':
        return await handleImportMarkdownFile(args);
      case 'link_document':
        return await handleLinkDocument(args);
      case 'get_document_links':
        return await handleGetDocumentLinks(args);
      default:
        throw new Error(`Unknown tool: ${name}`);
    }
  } catch (error) {
    console.error(`Error in tool ${name}:`, error);
    return {
      content: [{
        type: 'text',
        text: `‚ùå Error: ${error.message}`
      }],
      isError: true
    };
  }
});

// =============================================
// Ìï∏Îì§Îü¨ Ìï®ÏàòÎì§
// =============================================

async function handleCreateDocument(args) {
  const { title, content, doc_type, category, tags, summary, linked_entity_type, linked_entity_id, link_type } = args;

  // Insert document
  const insertDoc = db.prepare(`
    INSERT INTO documents (title, content, doc_type, category, tags, summary, created_by)
    VALUES (?, ?, ?, ?, ?, ?, 'mcp-user')
  `);
  
  const result = insertDoc.run(
    title,
    content,
    doc_type,
    category || null,
    tags ? JSON.stringify(tags) : null,
    summary || null
  );
  
  const documentId = result.lastInsertRowid;

  // Link to entity if specified
  if (linked_entity_type && linked_entity_id) {
    const insertLink = db.prepare(`
      INSERT INTO document_links (document_id, linked_entity_type, linked_entity_id, link_type)
      VALUES (?, ?, ?, ?)
    `);
    
    insertLink.run(documentId, linked_entity_type, linked_entity_id, link_type || 'notes');
  }

  return {
    content: [{
      type: 'text',
      text: `‚úÖ Î¨∏ÏÑúÍ∞Ä ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§!

**Î¨∏ÏÑú ID**: ${documentId}
**Ï†úÎ™©**: ${title}
**Ïú†Ìòï**: ${doc_type}
**Ïπ¥ÌÖåÍ≥†Î¶¨**: ${category || 'ÏóÜÏùå'}
**ÌÉúÍ∑∏**: ${tags ? tags.join(', ') : 'ÏóÜÏùå'}
${linked_entity_type ? `**Ïó∞Í≤∞Îê®**: ${linked_entity_type} #${linked_entity_id} (${link_type || 'notes'})` : ''}

üîç **Í≤ÄÏÉâ Ïù∏Îç±Ïã±**: ÏûêÎèôÏúºÎ°ú Ï†ÑÎ¨∏ Í≤ÄÏÉâ Ïù∏Îç±Ïä§Ïóê Ï∂îÍ∞ÄÎê®`
    }]
  };
}

async function handleSearchDocuments(args) {
  const { query, doc_type, category, limit = 10 } = args;

  let sql = `
    SELECT d.id, d.title, d.doc_type, d.category, d.summary, d.created_at,
           snippet(documents_fts, 1, '<mark>', '</mark>', '...', 32) as snippet
    FROM documents d
    JOIN documents_fts ON d.id = documents_fts.rowid
    WHERE documents_fts MATCH ?
  `;
  
  const params = [query];
  
  if (doc_type) {
    sql += ' AND d.doc_type = ?';
    params.push(doc_type);
  }
  
  if (category) {
    sql += ' AND d.category = ?';
    params.push(category);
  }
  
  sql += ' ORDER BY documents_fts.bm25 LIMIT ?';
  params.push(limit);

  const results = db.prepare(sql).all(...params);

  if (results.length === 0) {
    return {
      content: [{
        type: 'text',
        text: `üîç Í≤ÄÏÉâ Í≤∞Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§.

**Í≤ÄÏÉâÏñ¥**: "${query}"
${doc_type ? `**Î¨∏ÏÑú Ïú†Ìòï**: ${doc_type}` : ''}
${category ? `**Ïπ¥ÌÖåÍ≥†Î¶¨**: ${category}` : ''}

üí° **Í≤ÄÏÉâ ÌåÅ**:
- Îã§Î•∏ ÌÇ§ÏõåÎìú ÏãúÎèÑ
- ÌïÑÌÑ∞ Ï°∞Í±¥ ÏôÑÌôî
- Ï†ÑÏ≤¥ Î¨∏ÏÑú Î™©Î°ù: \`list_documents\` ÏÇ¨Ïö©`
      }]
    };
  }

  return {
    content: [{
      type: 'text',
      text: `üîç Í≤ÄÏÉâ Í≤∞Í≥º (${results.length}Í∞ú)

**Í≤ÄÏÉâÏñ¥**: "${query}"
${doc_type ? `**ÌïÑÌÑ∞**: ${doc_type}` : ''}
${category ? `**Ïπ¥ÌÖåÍ≥†Î¶¨**: ${category}` : ''}

${results.map(doc => `
**[${doc.id}] ${doc.title}**
üìã Ïú†Ìòï: ${doc.doc_type} | üìÇ Ïπ¥ÌÖåÍ≥†Î¶¨: ${doc.category || 'ÏóÜÏùå'}
üìÖ ÏÉùÏÑ±: ${new Date(doc.created_at).toLocaleDateString('ko-KR')}
üìù ÏöîÏïΩ: ${doc.summary || 'ÏóÜÏùå'}
üîç Î∞úÍ≤¨: ${doc.snippet}
---`).join('\n')}

üí° ÌäπÏ†ï Î¨∏ÏÑú Î≥¥Í∏∞: \`get_document\` ÏÇ¨Ïö©`
    }]
  };
}

async function handleGetDocument(args) {
  const { id } = args;

  const doc = db.prepare(`
    SELECT d.*, 
           GROUP_CONCAT(
             dl.linked_entity_type || ':' || dl.linked_entity_id || ':' || dl.link_type, 
             '|'
           ) as links
    FROM documents d
    LEFT JOIN document_links dl ON d.id = dl.document_id
    WHERE d.id = ?
    GROUP BY d.id
  `).get(id);

  if (!doc) {
    return {
      content: [{
        type: 'text',
        text: `‚ùå ID ${id}Ïóê Ìï¥ÎãπÌïòÎäî Î¨∏ÏÑúÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.`
      }]
    };
  }

  const tags = doc.tags ? JSON.parse(doc.tags) : [];
  const links = doc.links ? doc.links.split('|').map(link => {
    const [type, id, linkType] = link.split(':');
    return { type, id, linkType };
  }) : [];

  return {
    content: [{
      type: 'text',
      text: `üìÑ **${doc.title}**

**Î¨∏ÏÑú ID**: ${doc.id}
**Ïú†Ìòï**: ${doc.doc_type}
**Ïπ¥ÌÖåÍ≥†Î¶¨**: ${doc.category || 'ÏóÜÏùå'}
**ÏÉÅÌÉú**: ${doc.status}
**ÌÉúÍ∑∏**: ${tags.join(', ') || 'ÏóÜÏùå'}
**ÏÉùÏÑ±Ïùº**: ${new Date(doc.created_at).toLocaleString('ko-KR')}
**ÏàòÏ†ïÏùº**: ${new Date(doc.updated_at).toLocaleString('ko-KR')}
**ÏûëÏÑ±Ïûê**: ${doc.created_by}
**Î≤ÑÏ†Ñ**: ${doc.version}

${doc.summary ? `**ÏöîÏïΩ**: ${doc.summary}\n` : ''}
${links.length > 0 ? `**Ïó∞Í≤∞Îêú Ìï≠Î™©**:\n${links.map(link => `- ${link.type} #${link.id} (${link.linkType})`).join('\n')}\n` : ''}

---

${doc.content}`
    }]
  };
}

async function handleUpdateDocument(args) {
  const { id, title, content, summary, status, tags } = args;

  // Check if document exists
  const existing = db.prepare('SELECT id FROM documents WHERE id = ?').get(id);
  if (!existing) {
    throw new Error(`Document ID ${id} not found`);
  }

  // Build update query dynamically
  const updates = [];
  const params = [];

  if (title !== undefined) { updates.push('title = ?'); params.push(title); }
  if (content !== undefined) { updates.push('content = ?'); params.push(content); }
  if (summary !== undefined) { updates.push('summary = ?'); params.push(summary); }
  if (status !== undefined) { updates.push('status = ?'); params.push(status); }
  if (tags !== undefined) { updates.push('tags = ?'); params.push(JSON.stringify(tags)); }
  
  updates.push('updated_at = CURRENT_TIMESTAMP');
  updates.push('version = version + 1');
  params.push(id);

  const sql = `UPDATE documents SET ${updates.join(', ')} WHERE id = ?`;
  db.prepare(sql).run(...params);

  return {
    content: [{
      type: 'text',
      text: `‚úÖ Î¨∏ÏÑú ID ${id}Í∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏ÎêòÏóàÏäµÎãàÎã§.

**ÏóÖÎç∞Ïù¥Ìä∏Îêú ÌïÑÎìú**:
${title ? `- Ï†úÎ™©: ${title}` : ''}
${content ? `- ÎÇ¥Ïö©: ÏóÖÎç∞Ïù¥Ìä∏Îê®` : ''}
${summary ? `- ÏöîÏïΩ: ${summary}` : ''}
${status ? `- ÏÉÅÌÉú: ${status}` : ''}
${tags ? `- ÌÉúÍ∑∏: ${tags.join(', ')}` : ''}

üîÑ **Î≤ÑÏ†Ñ**: ÏûêÎèô Ï¶ùÍ∞Ä
üìÖ **ÏàòÏ†ï ÏãúÍ∞Ñ**: ${new Date().toLocaleString('ko-KR')}`
    }]
  };
}

async function handleDeleteDocument(args) {
  const { id } = args;

  const doc = db.prepare('SELECT title FROM documents WHERE id = ?').get(id);
  if (!doc) {
    throw new Error(`Document ID ${id} not found`);
  }

  db.prepare('DELETE FROM documents WHERE id = ?').run(id);

  return {
    content: [{
      type: 'text',
      text: `üóëÔ∏è Î¨∏ÏÑúÍ∞Ä ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.

**Î¨∏ÏÑú ID**: ${id}
**Ï†úÎ™©**: ${doc.title}

‚ö†Ô∏è **Ï£ºÏùò**: Ïó∞Í≤∞Îêú ÎßÅÌÅ¨ÏôÄ Í¥ÄÍ≥ÑÎèÑ Ìï®Íªò ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.`
    }]
  };
}

async function handleListDocuments(args) {
  const { doc_type, category, status, limit = 20 } = args;

  let sql = 'SELECT * FROM document_overview WHERE 1=1';
  const params = [];

  if (doc_type) {
    sql += ' AND doc_type = ?';
    params.push(doc_type);
  }

  if (category) {
    sql += ' AND category = ?';
    params.push(category);
  }

  if (status) {
    sql += ' AND status = ?';
    params.push(status);
  }

  sql += ' ORDER BY updated_at DESC LIMIT ?';
  params.push(limit);

  const docs = db.prepare(sql).all(...params);

  return {
    content: [{
      type: 'text',
      text: `üìö Î¨∏ÏÑú Î™©Î°ù (${docs.length}Í∞ú)

${doc_type ? `üìã **ÌïÑÌÑ∞ - Ïú†Ìòï**: ${doc_type}` : ''}
${category ? `üìÇ **ÌïÑÌÑ∞ - Ïπ¥ÌÖåÍ≥†Î¶¨**: ${category}` : ''}
${status ? `üè∑Ô∏è **ÌïÑÌÑ∞ - ÏÉÅÌÉú**: ${status}` : ''}

${docs.map(doc => `
**[${doc.id}] ${doc.title}**
üìã ${doc.doc_type} | üìÇ ${doc.category || 'ÏóÜÏùå'} | üè∑Ô∏è ${doc.status}
üìÖ ${new Date(doc.updated_at).toLocaleDateString('ko-KR')}
üîó Ïó∞Í≤∞: ${doc.linked_entities_count}Í∞ú | üìë Í¥ÄÎ†® Î¨∏ÏÑú: ${doc.related_docs_count}Í∞ú
üìù ${doc.summary || 'ÏöîÏïΩ ÏóÜÏùå'}
---`).join('\n')}

üí° **ÏÇ¨Ïö©Î≤ï**:
- Î¨∏ÏÑú Î≥¥Í∏∞: \`get_document\` ÏÇ¨Ïö©
- Í≤ÄÏÉâ: \`search_documents\` ÏÇ¨Ïö©`
    }]
  };
}

async function handleImportMarkdownFile(args) {
  const { file_path, doc_type, category, tags, auto_summary = true } = args;

  if (!fs.existsSync(file_path)) {
    throw new Error(`File not found: ${file_path}`);
  }

  const content = fs.readFileSync(file_path, 'utf8');
  const title = path.basename(file_path, '.md').replace(/[-_]/g, ' ');

  // Auto-generate summary from first paragraph if enabled
  let summary = null;
  if (auto_summary) {
    const firstParagraph = content.split('\n\n')[0];
    summary = firstParagraph.replace(/^#+\s*/, '').substring(0, 200);
  }

  const insertDoc = db.prepare(`
    INSERT INTO documents (title, content, doc_type, category, file_path, tags, summary, created_by)
    VALUES (?, ?, ?, ?, ?, ?, ?, 'file-import')
  `);
  
  const result = insertDoc.run(
    title,
    content,
    doc_type,
    category || null,
    file_path,
    tags ? JSON.stringify(tags) : null,
    summary
  );

  return {
    content: [{
      type: 'text',
      text: `üìÅ ÌååÏùºÏùÑ Î¨∏ÏÑúÎ°ú Í∞ÄÏ†∏ÏôîÏäµÎãàÎã§!

**Î¨∏ÏÑú ID**: ${result.lastInsertRowid}
**ÌååÏùº**: ${file_path}
**Ï†úÎ™©**: ${title}
**Ïú†Ìòï**: ${doc_type}
**ÌÅ¨Í∏∞**: ${content.length}Ïûê
**ÏûêÎèô ÏöîÏïΩ**: ${auto_summary ? 'ÏÉùÏÑ±Îê®' : 'Í±¥ÎÑàÎúÄ'}

‚úÖ Ï†ÑÎ¨∏ Í≤ÄÏÉâ Ïù∏Îç±Ïä§Ïóê ÏûêÎèô Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§.`
    }]
  };
}

async function handleLinkDocument(args) {
  const { document_id, entity_type, entity_id, link_type = 'notes' } = args;

  // Check if document exists
  const doc = db.prepare('SELECT title FROM documents WHERE id = ?').get(document_id);
  if (!doc) {
    throw new Error(`Document ID ${document_id} not found`);
  }

  // Insert link
  const insertLink = db.prepare(`
    INSERT OR IGNORE INTO document_links (document_id, linked_entity_type, linked_entity_id, link_type)
    VALUES (?, ?, ?, ?)
  `);
  
  const result = insertLink.run(document_id, entity_type, entity_id, link_type);

  return {
    content: [{
      type: 'text',
      text: `üîó Ïó∞Í≤∞Ïù¥ ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§!

**Î¨∏ÏÑú**: [${document_id}] ${doc.title}
**Ïó∞Í≤∞ ÎåÄÏÉÅ**: ${entity_type} #${entity_id}
**ÎßÅÌÅ¨ Ïú†Ìòï**: ${link_type}
**ÏÉÅÌÉú**: ${result.changes > 0 ? 'ÏÉàÎ°ú ÏÉùÏÑ±Îê®' : 'Ïù¥ÎØ∏ Ï°¥Ïû¨Ìï®'}

üí° Ïó∞Í≤∞ ÌôïÏù∏: \`get_document_links\` ÏÇ¨Ïö©`
    }]
  };
}

async function handleGetDocumentLinks(args) {
  const { document_id } = args;

  const doc = db.prepare('SELECT title FROM documents WHERE id = ?').get(document_id);
  if (!doc) {
    throw new Error(`Document ID ${document_id} not found`);
  }

  const links = db.prepare(`
    SELECT linked_entity_type, linked_entity_id, link_type, created_at
    FROM document_links
    WHERE document_id = ?
    ORDER BY created_at DESC
  `).all(document_id);

  return {
    content: [{
      type: 'text',
      text: `üîó Î¨∏ÏÑú Ïó∞Í≤∞ Í¥ÄÍ≥Ñ

**Î¨∏ÏÑú**: [${document_id}] ${doc.title}
**Ï¥ù Ïó∞Í≤∞**: ${links.length}Í∞ú

${links.length > 0 ? 
  links.map(link => `
- **${link.linked_entity_type} #${link.linked_entity_id}**
  Ïú†Ìòï: ${link.link_type}
  ÏÉùÏÑ±: ${new Date(link.created_at).toLocaleDateString('ko-KR')}
  `).join('\n') :
  'Ïó∞Í≤∞Îêú Ìï≠Î™©Ïù¥ ÏóÜÏäµÎãàÎã§.'
}

üí° ÏÉà Ïó∞Í≤∞ ÏÉùÏÑ±: \`link_document\` ÏÇ¨Ïö©`
    }]
  };
}

// =============================================
// ÏÑúÎ≤Ñ ÏãúÏûë
// =============================================

async function main() {
  try {
    await initializeServer();
    
    const transport = new StdioServerTransport();
    await server.connect(transport);
    
    console.log('‚úÖ Document Management MCP Server ready - 9 document tools available');
    
  } catch (error) {
    console.error('üí• Server startup failed:', error);
    process.exit(1);
  }
}

// Ï¢ÖÎ£å Ïãú Ï†ïÎ¶¨
process.on('SIGINT', async () => {
  console.log('\nüîÑ Shutting down document server...');
  if (db) {
    db.close();
  }
  process.exit(0);
});

main();